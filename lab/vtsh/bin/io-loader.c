#define _GNU_SOURCE  // включаем расширенные GNU-возможности до подключения заголовков, чтобы активировать нестандартные функции GNU C Library
#define _POSIX_C_SOURCE 200809L  // фиксируем уровень POSIX для доступа к современным API (например, getline и clock_gettime), гарантируя совместимость прототипов
#include "io-loader.h"  // подгружаем объявление публичных функций и констант этого модуля, формируя связку с заголовком библиотеки

#include <fcntl.h>  // даёт доступ к open, fcntl и файловым флагам, необходимым для настройки поведения файловых дескрипторов
#include <stdint.h>  // предоставляет целочисленные типы с фиксированной шириной, чтобы выражать размеры и смещения без неопределённости
#include <stdio.h>  // подключает стандартный ввод/вывод, включая printf и fprintf, используемые для информационных и диагностических сообщений
#include <stdlib.h>  // содержит функции преобразования строк и управления памятью, что важно при разборе аргументов и выделении буферов
#include <string.h>  // предоставляет строковые утилиты, такие как strcmp и strchr, применяемые при сопоставлении ключей командной строки
#include <sys/stat.h>  // нужен для структуры stat и fstat, чтобы получать метаданные о файле и его размере
#include <sys/types.h>  // объявляет базовые системные типы (off_t и др.), обеспечивая переносимость расчётов смещений
#include <time.h>  // обеспечивает работу с временем и clock_gettime, которые используются при замерах производительности операций
#include <unistd.h>  // даёт POSIX-функции уровня системы (close, pread, pwrite), формируя базовые операции ввода-вывода

#define NSEC_PER_SEC 1000000000L  // число наносекунд в одной секунде для расчётов времени, удобное при нормализации длительности операций

/*
 * ПОДДЕРЖКА ПЛАТФОРМЕННЫХ ФЛАГОВ
 * --------------------------------------------------------------------------
 * Некоторые системные флаги (в частности O_DIRECT) присутствуют не на всех
 * платформах. Чтобы код оставался переносимым, создаём заглушку, если флаг
 * отсутствует. Это позволяет компилировать программу в окружениях вроде macOS,
 * где доступно альтернативное API (F_NOCACHE), но нет прямого аналога O_DIRECT.
 */
#ifndef O_DIRECT  // проверяем, определён ли флаг прямого ввода-вывода в системных заголовках
#define O_DIRECT 0  // подставляем ноль, чтобы код с OR по-прежнему компилировался и работал как обычный ввод-вывод
#endif  // конец защиты от повторного определения O_DIRECT, предотвращающий конфликт символов

/*
 * СЕКЦИЯ КОНСТАНТ КОНФИГУРАЦИИ
 * --------------------------------------------------------------------------
 * Ниже задаются константы, управляющие поведением программы по умолчанию.
 * FILE_MODE_PERMISSIONS определяет права новых файлов, а MIN_ARG_COUNT задаёт
 * минимальный набор аргументов, необходимый для корректного запуска утилиты.
 */
const int FILE_MODE_PERMISSIONS = 0666;  // режим доступа при создании файлов (rw-rw-rw-); используется для open(O_CREAT)
const int MIN_ARG_COUNT = 9;  // минимальное число аргументов командной строки для запуска, покрывающее обязательные ключи

// ------------------------------ ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ------------------------------  // служебные функции модуля
/*
 * Вспомогательные процедуры отвечают за вывод справки пользователю и разбор
 * составных аргументов. Они изолируют повторяемую логику и позволяют основной
 * функции main сосредоточиться на настройке параметров и выполнении замеров.
 */

// usage() — выводит корректный синтаксис запуска утилиты пользователю и подчёркивает обязательные параметры
void usage(const char* program_name) {  // объявляем функцию подсказки по использованию, принимающую имя исполняемого файла
  fprintf(  // печатаем инструкцию в поток ошибок, чтобы пользователь увидел её даже при отсутствии стандартного вывода
      stderr,  // используем stderr, чтобы не смешивать подсказку с полезным выводом программы и облегчить перенаправление
      "Usage: %s --rw read|write --block_size <n> --block_count <n> --file "  // первая строка подсказки с обязательными ключами и порядком следования
      "<path>\n"  // продолжаем сообщение переносом строки, чтобы вынести путь на отдельную строку
      "       [--range A-B] [--direct on|off] [--type sequence|random] "  // описываем необязательные параметры запуска и допустимые значения
      "[--repetitions N]\n",  // завершаем подсказку и готовим форматы для числовых аргументов
      program_name  // подставляем имя программы в шаблон, чтобы строка была актуальна при любых именах бинарника
  );  // завершаем вызов fprintf, что отправляет данные в буфер stderr
}  // конец функции usage, возвращающей управление без дополнительного значения

// parse_range() — разбирает строку формата "A-B" и сохраняет границы диапазона, гарантируя корректность числовых значений
int parse_range(const char* range_str, off_t* start_val, off_t* end_val) {  // принимаем строку диапазона и указатели на выходные значения, чтобы модифицировать их внутри функции
  if (!range_str) {  // проверяем, передана ли строка диапазона, защищаясь от ошибочного вызова с NULL
    return -1;  // если нет, сигнализируем об ошибке, чтобы вызывающая сторона знала, что диапазон не разобран
  }  // закрываем проверку range_str, тем самым предотвращая обращение к памяти по неверному указателю

  char* dash_position = strchr(range_str, '-');  // ищем символ '-' как разделитель границ, поскольку диапазон задаётся форматом A-B
  if (!dash_position) {  // если разделителя нет, значит строка не соответствует ожидаемому формату
    return -1;  // возвращаем ошибку формата, чтобы вызвать повторный разбор или вывести сообщение пользователю
  }  // завершаем проверку наличия '-', тем самым гарантируя корректность дальнейшего разбиения

  *dash_position = '\0';  // временно разрезаем строку, чтобы получить начало и конец диапазона как две отдельные подстроки без копирования
  char* endptr = NULL;  // указатель для контроля корректности преобразований строки в число, используемый strtoll

  long long start_long = strtoll(range_str, &endptr, 10);  // переводим левую границу в целое число, используя десятичную систему счисления
  if (*endptr != '\0' || start_long < 0) {  // проверяем, что вся строка корректна, число не содержит лишних символов и не отрицательно, так как смещения должны быть неотрицательными
    *dash_position = '-';  // восстанавливаем исходную строку, чтобы не оставить её в модифицированном состоянии
    return -1;  // сообщаем об ошибке парсинга, чтобы вызывающий код проигнорировал испорченный диапазон
  }  // конец проверки корректности start_long, который предотвращает undefined behavior при отрицательных смещениях

  long long end_long = strtoll(dash_position + 1, &endptr, 10);  // парсим правую границу диапазона, начиная с символа после '-' и используя тот же механизм проверки
  if (*endptr != '\0' || end_long < 0) {  // убеждаемся в корректности числа, чтобы избежать отрицательного конца диапазона или мусора в строке
    *dash_position = '-';  // восстанавливаем оригинальный разделитель, сохраняя входную строку неизменной для вызывающего кода
    return -1;  // возвращаем ошибку, сигнализируя об отсутствии корректной правой границы
  }  // конец проверки end_long, предотвращающей некорректное использование диапазона в расчётах смещений

  *start_val = (off_t)start_long;  // сохраняем начало диапазона в выходной аргумент, приводя тип к off_t для дальнейших файловых операций
  *end_val = (off_t)end_long;  // сохраняем конец диапазона в выходной аргумент, заключая результат в совместимый тип смещения

  *dash_position = '-';  // возвращаем символ '-' на место, чтобы исходная строка оставалась пригодной для повторного чтения или логирования
  return 0;  // уведомляем об успешном разборе диапазона, позволяя вызывающему коду использовать полученные границы
}  // завершение parse_range, обеспечивающее корректное состояние строки range_str к моменту выхода

// ------------------------------ MAIN ------------------------------  // входная точка программы

int main(int argc, char** argv) {  // основная функция получает количество аргументов и их значения, являясь входной точкой программы
  if (argc < MIN_ARG_COUNT) {  // проверяем, достаточно ли аргументов передано пользователем, чтобы гарантировать наличие обязательных ключей
    usage(argv[0]);  // выводим подсказку по использованию при нехватке аргументов, чтобы пользователь увидел корректный синтаксис запуска
    return 1;  // прекращаем работу с кодом ошибки, сигнализируя оболочке о некорректном вводе
  }  // конец проверки минимального числа аргументов, после которой можно смело читать параметры

  // -------------------- Переменные конфигурации --------------------  // объявляем переменные для параметров, получаемых из аргументов
  /*
   * Здесь инициализируются все сущности, описывающие желаемый сценарий теста:
   * режим чтения или записи, размеры блоков, используемый файл, границы
   * диапазона, флаги прямого ввода-вывода, тип доступа (последовательный
   * либо случайный) и число повторов. Переменные получают значения из
   * аргументов командной строки и затем управляют основным циклом работы.
   */
  const char* rw_mode_str = NULL;  // режим работы: "read" или "write"; хранит исходную строку, чтобы позже конвертировать её в флаг
  size_t block_size_bytes = 0;  // размер блока операции ввода-вывода; используется при выделении буфера и вызовах pwrite/pread
  size_t block_count_total = 0;  // количество блоков, которые нужно обработать; определяет длину внутреннего цикла
  const char* file_path_str = NULL;  // путь к целевому файлу; применяется при открытии дескриптора
  off_t range_start_val = 0;  // начало диапазона смещений; задаёт нижнюю границу рассматриваемой части файла
  off_t range_end_val = 0;  // конец диапазона смещений; определяет верхнюю границу, исключая операции за пределами интересующей области
  int is_range_given_flag = 0;  // отметка, что параметр --range указан; помогает отличать режим по умолчанию от пользовательского
  int direct_io_flag = 0;  // флаг запроса прямого ввода-вывода (O_DIRECT); управляет попыткой отключить файловый кэш
  int is_sequence_access = 1;  // режим доступа: 1 — последовательный, 0 — случайный; влияет на выбор индекса блока в цикле
  int repetitions_total = 1;  // количество повторов полного прохода по блокам; даёт возможность повторять замеры для усреднения

  // -------------------- Парсинг аргументов командной строки --------------------  // разбираем ключи и значения, переданные пользователем
  /*
   * Следующий цикл перебирает все элементы argv и распознаёт известные ключи.
   * Для каждого параметра выполняется валидация и приведение типов, а при
   * обнаружении ошибок программа сразу сообщает пользователю и завершает
   * работу. Такой подход предотвращает накопление некорректного состояния и
   * упрощает диагностику проблем запуска.
   */
  int arg_index = 0;  // счётчик текущего аргумента, позволяющий проходить по argv без создания дополнительных структур
  /*
   * Вместо хранения промежуточных структур мы выполняем один последовательный
   * проход по всем аргументам. Такой подход делает поведение максимально
   * предсказуемым: каждый ключ обрабатывается сразу после распознавания,
   * сопровождается собственной проверкой корректности и при необходимости
   * немедленно завершает программу с сообщением об ошибке. Благодаря этому
   * пользователю проще диагностировать проблемы запуска, а основной цикл I/O
   * получает уже проверенную конфигурацию без дополнительных проверок.
   */
  for (arg_index = 1; arg_index < argc; ++arg_index) {  // перебираем аргументы, пропуская имя программы, чтобы обрабатывать только ключи и значения
    if (strcmp(argv[arg_index], "--rw") == 0 && arg_index + 1 < argc) {  // ищем ключ режима чтение/запись и убеждаемся, что за ним следует значение
      rw_mode_str = argv[++arg_index];  // забираем значение (read или write) и сдвигаем индекс, чтобы не обрабатывать его повторно
      continue;  // переходим к следующему аргументу цикла, поскольку ключ успешно обработан
    }  // конец обработки --rw, позволяющий определить, будет ли программа писать или читать данные

    if (strcmp(argv[arg_index], "--block_size") == 0 && arg_index + 1 < argc) {  // проверяем наличие ключа размера блока и валидируем, что для него дан аргумент
      char* endptr = NULL;  // указатель для контроля преобразования строки в число, отлавливающий некорректные символы
      long long temp_val = strtoll(argv[++arg_index], &endptr, 10);  // читаем значение размера блока в байтах и переводим его в целое
      if (*endptr != '\0' || temp_val <= 0) {  // убеждаемся, что число корректное и положительное, исключая некорректные единицы измерения
        fprintf(stderr, "Invalid --block_size value\n");  // сообщаем об ошибке пользователю, чтобы он скорректировал ввод
        return 1;  // завершаем программу из-за некорректного параметра, предотвращая использование невалидного размера
      }  // завершение проверки block_size, обеспечивающей целостность конфигурации
      block_size_bytes = (size_t)temp_val;  // сохраняем размер блока для дальнейшей работы, приводя тип к ожидаемому размеру
      continue;  // идём к следующему аргументу, раз обработка текущего завершена успешно
    }  // конец обработки --block_size, задающего фундаментальную единицу работы

    if (strcmp(argv[arg_index], "--block_count") == 0 && arg_index + 1 < argc) {  // обрабатываем ключ количества блоков и проверяем наличие значения
      char* endptr = NULL;  // указатель для проверки корректности числа, повторно используемый для снижения количества временных переменных
      long long temp_val = strtoll(argv[++arg_index], &endptr, 10);  // читаем число блоков, которые нужно обработать, ожидая положительное целое
      if (*endptr != '\0' || temp_val <= 0) {  // проверяем, что число корректное и больше нуля, исключая нулевые замеры
        fprintf(stderr, "Invalid --block_count value\n");  // предупреждаем об ошибке, чтобы пользователь увидел причину отказа
        return 1;  // прекращаем выполнение из-за неправильного аргумента, сохраняя программу в предсказуемом состоянии
      }  // конец проверки block_count, гарантирующей корректный внешний цикл
      block_count_total = (size_t)temp_val;  // сохраняем количество блоков, переводя его в тип size_t для индексации
      continue;  // продолжаем разбор аргументов, поскольку ключ успешно обработан
    }  // завершение обработки --block_count, определяющего длительность работы

    if (strcmp(argv[arg_index], "--file") == 0 && arg_index + 1 < argc) {  // проверяем указание пути к файлу и удостоверяемся в наличии строки пути
      file_path_str = argv[++arg_index];  // сохраняем путь и пропускаем значение в списке аргументов, чтобы не анализировать его повторно
      continue;  // переходим к следующему аргументу, так как файл выбран
    }  // конец обработки --file, связывающего программу с конкретным файлом на диске

    if (strcmp(argv[arg_index], "--range") == 0 && arg_index + 1 < argc) {  // анализируем указание диапазона смещений и проверяем наличие параметра вида A-B
      if (parse_range(argv[++arg_index], &range_start_val, &range_end_val) == 0) {  // пытаемся разобрать значение диапазона и сохраняем результат в выходные переменные
        is_range_given_flag = 1;  // отмечаем, что диапазон успешно задан, чтобы позже ограничить I/O указанными пределами
      }  // конец успешного разбора диапазона, оставляющего флаг в состоянии "диапазон задан"
      continue;  // переходим к следующему аргументу, так как --range обработан либо проигнорирован из-за ошибки
    }  // завершение обработки --range, позволяющего запускать тест на отдельном фрагменте файла

    if (strcmp(argv[arg_index], "--direct") == 0 && arg_index + 1 < argc) {  // проверяем флаг прямого ввода-вывода и убеждаемся, что передано значение on/off
      direct_io_flag = (strcmp(argv[++arg_index], "on") == 0) ? 1 : 0;  // включаем флаг только если значение равно "on", иначе оставляем стандартный буферизированный режим
      continue;  // продолжаем разбор аргументов, поскольку ключ обработан
    }  // конец обработки --direct, подготавливающего опцию отключения кэширования

    if (strcmp(argv[arg_index], "--type") == 0 && arg_index + 1 < argc) {  // разбираем тип доступа к блокам и проверяем, что передано ожидаемое значение
      is_sequence_access = (strcmp(argv[++arg_index], "sequence") == 0) ? 1 : 0;  // последовательный доступ, если значение "sequence"; иначе переключаемся на случайный режим
      continue;  // переходим к следующему ключу, так как режим доступа определён
    }  // завершение обработки --type, влияющего на стратегию выбора блока

    if (strcmp(argv[arg_index], "--repetitions") == 0 && arg_index + 1 < argc) {  // проверяем параметр количества повторов и удостоверяемся в наличии числа
      char* endptr = NULL;  // указатель для контроля преобразования числа, повторно используемый для читаемости
  long long temp_val = strtoll(argv[++arg_index], &endptr, 10);  // извлекаем следующий аргумент, сначала переводя число повторов в long long, чтобы проверить его без переполнения; набор повторов помогает усреднить серию замеров и сгладить случайный шум
      if (*endptr != '\0' || temp_val <= 0) {  // убеждаемся, что число корректное и больше нуля, иначе повторять тест бессмысленно
        fprintf(stderr, "Invalid --repetitions value\n");  // сигнализируем об ошибке пользователю, объясняя причину отказа
        return 1;  // завершаем программу из-за неверного аргумента, чтобы не запускать тест с некорректными параметрами
      }  // конец проверки repetitions, защищающей цикл повторений от недопустимых значений
  repetitions_total = (int)temp_val;  // сохраняем количество повторов, приводя тип к int, потому что сам цикл индексируется int'ом и мы уже ограничили значение разумными положительными числами
      continue;  // продолжаем обработку аргументов, поскольку ключ успешно интерпретирован
    }  // завершение обработки --repetitions, определяющего длительность серии экспериментов

    fprintf(stderr, "Unknown or malformed arg: %s\n", argv[arg_index]);  // сообщаем о незнакомом или неверном аргументе, чтобы упростить диагностику
    usage(argv[0]);  // повторно выводим подсказку по синтаксису, демонстрируя ожидаемую последовательность ключей
    return 1;  // прекращаем работу, так как не разобрались с аргументом, предотвращая запуск в неопределённом состоянии
  }  // конец цикла разбора аргументов

  /*
   * На этом этапе обязательно убеждаемся, что заданы все критически важные
   * аргументы. Без них программа не сможет корректно настроить буферы и
   * выполнить I/O. Проверка объединена в одно условие, позволяя быстро
   * обнаружить пропущенный ключ и уведомить пользователя повторной подсказкой.
   */
  if (!rw_mode_str || !block_size_bytes || !block_count_total || !file_path_str) {  // проверяем, заданы ли все обязательные параметры, гарантируя корректность конфигурации
    usage(argv[0]);  // выдаём подсказку при неполном наборе аргументов, помогая пользователю обнаружить пропущенное значение
    return 1;  // завершаем работу с сообщением об ошибке, так как дальнейшее выполнение было бы бессмысленным
  }  // конец проверки обязательных опций, после которой можно переходить к инициализации

  int do_write_flag = (strcmp(rw_mode_str, "write") == 0) ? 1 : 0;  // определяем, требуется ли режим записи (иначе будет чтение), переводя строковый параметр в быстродействующий флаг

  // -------------------- Открытие файла --------------------  // настраиваем и открываем файл для ввода-вывода
  /*
   * Далее формируется набор флагов для системного вызова open. Вместо того,
   * чтобы полагаться на умолчания, мы явно указываем режимы чтения/записи и
   * при необходимости дополняем их O_DIRECT. Такой подход делает поведение
   * программы предсказуемым и переносимым между платформами.
   */
  int open_flags = do_write_flag ? (O_CREAT | O_RDWR) : O_RDONLY;  // выбираем флаги открытия в зависимости от режима операции, чтобы задать корректные права доступа
#ifdef O_DIRECT  // если доступен флаг прямого ввода-вывода, то можно управлять кэшированием на уровне ядра
  if (direct_io_flag) {  // проверяем, запросил ли пользователь прямой ввод-вывод через аргумент командной строки
    open_flags |= O_DIRECT;  // добавляем соответствующий флаг при открытии файла, тем самым пытаясь обойти файловый кэш и добиться предсказуемых замеров
  }  // завершаем обработку direct I/O для доступной платформы, оставляя типичный буферизированный режим, если опция не указана
#else  // ветка, если O_DIRECT не определён в системе
  // Здесь ничего не добавляем, fallback будет позже после открытия файла, чтобы применить платформенные альтернативы вроде F_NOCACHE на macOS
#endif  // конец условной обработки флага O_DIRECT

  int fd_file = open(file_path_str, open_flags, FILE_MODE_PERMISSIONS);  // открываем или создаём файл с заданными правами, получая файловый дескриптор
  if (fd_file < 0) {  // проверяем, успешно ли выполнено открытие, чтобы не продолжать с невалидным дескриптором
    perror("open");  // выводим системную ошибку, если открыть не удалось, предоставляя контекст из errno
    return 1;  // завершаем программу из-за ошибки открытия файла, так как дальнейшие операции невозможны
  }  // конец проверки результата open, после которой дескриптор гарантированно валиден

#ifndef O_DIRECT  // если платформа не поддерживает O_DIRECT нативно
  if (direct_io_flag) {  // проверяем, просил ли пользователь прямой ввод-вывода, чтобы попытаться имитировать его другим способом
#if defined(__APPLE__)  // на macOS используем альтернативный механизм управления кэшированием
    if (fcntl(fd_file, F_NOCACHE, 1) == -1) {  // пытаемся отключить кэширование через fcntl, что приближает поведение к прямому I/O
      perror("fcntl(F_NOCACHE)");  // предупреждаем, если не удалось установить режим, позволяя пользователю знать об отсутствии эффекта
      // продолжаем выполнение без прямого ввода-вывода, это лишь предупреждение, так как программа всё ещё может работать с буферами
    }  // конец обработки fcntl на macOS, где успех означает минимальное вмешательство файлового кэша
#else  // для остальных систем без O_DIRECT, где аналогичных флагов может не быть
    fprintf(stderr,  // выводим предупреждение, что режим прямого ввода-вывода недоступен и тест будет использовать обычное кэширование
            "Warning: direct I/O requested but O_DIRECT is not available on this platform; continuing without direct I/O\n");
#endif  // завершение платформо-зависимой обработки, покрывающей разные варианты окружений
  }  // конец обработки direct_io_flag для систем без O_DIRECT, оставляющий программу в рабочем состоянии
#endif  // завершение блока без O_DIRECT

  struct stat file_stat_struct;  // структура для хранения информации о файле, которую мы заполним через fstat
  if (fstat(fd_file, &file_stat_struct) != 0) {  // запрашиваем метаданные файла, чтобы узнать его текущий размер и тип
    perror("fstat");  // сообщаем об ошибке, если fstat не удалось выполнить, облегчая поиск проблем с дескриптором
    close(fd_file);  // закрываем файл перед выходом, чтобы не оставлять висячие ресурсы
    return 1;  // завершаем программу из-за сбоя получения статуса файла, поскольку без размера невозможно продолжать расчёты
  }  // конец проверки результата fstat, обеспечивающей наличие достоверной информации о файле
  off_t file_total_size = file_stat_struct.st_size;  // сохраняем текущий размер файла для расчёта диапазонов и планирования записи

  // -------------------- Настройка диапазона --------------------  // определяем, какие смещения использовать при работе
  /*
   * Диапазон чтения или записи позволяет ограничить тестирование выбранным
   * сегментом файла. Если пользователь не указал диапазон, программа работает
   * с файлом целиком. При явном диапазоне дополнительно проверяются границы,
   * чтобы избежать некорректных или отрицательных смещений.
   */
  off_t io_range_start = 0;  // начальное смещение по умолчанию — начало файла; используется как базовая точка отсчёта
  off_t io_range_end = file_total_size;  // конечное смещение по умолчанию — конец файла; определяет верхнюю границу допустимых операций

  if (is_range_given_flag) {  // проверяем, указал ли пользователь диапазон, чтобы при необходимости сузить область операций
    if (range_start_val == 0 && range_end_val == 0) {  // если обе границы нули, используем весь файл, сохраняя совместимость со старым поведением
      io_range_start = 0;  // оставляем начало диапазона на нуле, сохраняя исходное значение
      io_range_end = file_total_size;  // устанавливаем конец диапазона на весь файл, игнорируя нулевой указанный конец
    } else {  // если диапазон задан конкретными числами и отличается от дефолта
      io_range_start = range_start_val;  // фиксируем начало диапазона согласно аргументу, что позволит смещать операции от указанной точки
      io_range_end = range_end_val;  // фиксируем конец диапазона, ограничивая максимальное смещение
      if (io_range_end <= io_range_start) {  // проверяем корректность границ, чтобы не получить отрицательное количество блоков
        fprintf(stderr, "Bad range\n");  // сообщаем о некорректном диапазоне, поясняя причину остановки
        close(fd_file);  // закрываем файловый дескриптор, чтобы не держать ресурс при ошибке конфигурации
        return 1;  // прекращаем выполнение из-за ошибки в аргументах диапазона, сохраняя программу в предсказуемом состоянии
      }  // конец проверки корректности границ диапазона, предотвращающий пустой или обратный диапазон
    }  // конец альтернативной ветки диапазона, обрабатывающей пользовательский ввод
  }  // завершение обработки диапазона, после которой установлены актуальные границы

  // -------------------- Подготовка файла для записи --------------------  // увеличиваем файл при необходимости в режиме записи
  /*
   * При работе в режиме записи важно убедиться, что файл достаточно велик,
   * чтобы вместить все блоки. Если размер недостаточен, выполняется ftruncate,
   * расширяющий файл вплоть до нужного объёма. Это предотвращает короткие
   * записи и ошибки EFBIG в процессе теста.
   */
  if (do_write_flag) {  // продолжаем только если выбрана запись, поскольку чтению не требуется изменение размера
    off_t needed_size = io_range_start + (off_t)block_size_bytes * (off_t)block_count_total;  // рассчитываем необходимый размер файла, учитывая смещение и количество блоков
    if (needed_size > file_total_size) {  // проверяем, достаточно ли текущего размера файла, чтобы избежать выхода за границы
      if (ftruncate(fd_file, needed_size) != 0) {  // пытаемся увеличить файл до нужного размера, используя системный вызов расширения
        perror("ftruncate");  // сообщаем о невозможности изменить размер, чтобы пользователь увидел первопричину
        close(fd_file);  // закрываем дескриптор, освобождая ресурс перед выходом
        return 1;  // завершаем программу из-за ошибки ftruncate, поскольку дальнейшая запись приведёт к коротким операциям
      }  // конец обработки успешного ftruncate, после которой размер файла соответствует ожиданиям
      file_total_size = needed_size;  // обновляем учёт размера файла после расширения, чтобы последующие расчёты опирались на фактические данные
      if (io_range_end < needed_size) {  // приводим конец диапазона в соответствие с новым размером, если пользователь до этого указал меньшую границу
        io_range_end = needed_size;  // расширяем диапазон до фактического размера, гарантируя отсутствие обрезания данных
      }  // конец корректировки конечного смещения, синхронизирующей диапазон с расширенным файлом
    }  // завершение проверки необходимости увеличения файла, исключающей лишние вызовы ftruncate
  }  // конец ветки подготовки файла для записи, после которой можно безопасно выполнять операции записи

  // -------------------- Выделение буфера --------------------  // резервируем память под рабочий буфер
  /*
   * Работа с прямым вводом-выводом и крупными блоками требует выровненной
   * памяти. posix_memalign позволяет выделить буфер, кратный размеру страницы,
   * что удовлетворяет требованиям O_DIRECT и повышает вероятность кеш-линии
   * оптимального размера.
   */
  size_t memory_alignment_bytes = (size_t)sysconf(_SC_PAGESIZE);  // определяем размер страницы памяти для выравнивания буфера, делая код переносимым между системами
  void* buffer_ptr = NULL;  // указатель на будущий буфер данных, который будет передаваться в pwrite/pread

  if (posix_memalign(&buffer_ptr, memory_alignment_bytes, block_size_bytes) != 0) {  // выделяем выровненную область памяти, требуя успеха для корректных операций direct I/O
    perror("posix_memalign");  // сообщаем об ошибке выделения памяти, чтобы пользователь видел, что недостаточно ресурсов или параметры некорректны
    close(fd_file);  // закрываем файловый дескриптор перед выходом, освобождая системный ресурс
    return 1;  // завершаем программу из-за невозможности выделить буфер, поскольку без него операции ввода-вывода невозможны
  }  // конец обработки posix_memalign, обеспечивающего корректные требования выравнивания

  if (do_write_flag) {  // если выполняется запись, подготовим данные, чтобы записывать воспроизводимый шаблон
    size_t byte_index = 0;  // объявляем индекс перебора байтов буфера, позволяя заполнить его пошагово
    for (byte_index = 0; byte_index < block_size_bytes; ++byte_index) {  // заполняем каждый байт буфера шаблоном, чтобы данные были непустыми и легко проверяемыми
      ((unsigned char*)buffer_ptr)[byte_index] = (unsigned char)(byte_index & 0xFF);  // записываем циклический шаблон данных в буфер, обеспечивая повторяемость и наглядность содержимого
    }  // завершение заполнения буфера данными, после чего блок готов к записи в файл
  }  // конец ветки подготовки буфера для записи, оставляющей буфер нетронутым при работе в режиме чтения

  // -------------------- Подготовка цикла IO --------------------  // устанавливаем параметры для повторений и режима доступа
  /*
   * Перед запуском основного цикла генератор случайных чисел инициализируется
   * текущим временем, чтобы последовательность случайных блоков отличалась
   * между запусками. Дополнительно вычисляется количество блоков в диапазоне,
   * что позволяет контролировать корректность заданных параметров.
   */
  srand((unsigned)time(NULL));  // инициализируем генератор случайных чисел текущим временем для случайного доступа, чтобы избежать повторяющихся паттернов

  off_t blocks_in_region = (io_range_end - io_range_start) / (off_t)block_size_bytes;  // рассчитываем количество блоков в выбранном диапазоне, используя разницу смещений
  if (blocks_in_region <= 0) {  // проверяем, что диапазон достаточно велик, иначе даже один блок не поместится
    fprintf(stderr, "Range too small for block_size\n");  // сообщаем о недостаточном диапазоне, явно указывая на потенциальную причину
    free(buffer_ptr);  // освобождаем ранее выделенный буфер, поддерживая корректную очистку ресурсов
    close(fd_file);  // закрываем файл, чтобы не оставлять дескриптор открытым
    return 1;  // прекращаем выполнение из-за некорректного диапазона, избегая деления на ноль и прочих ошибок
  }  // конец проверки блока диапазона, гарантируя, что хотя бы один блок можно обработать

  // -------------------- Основной цикл IO --------------------  // выполняем повторяющиеся проходы по блокам ввода-вывода
  /*
   * Внешний цикл отвечает за повторение всей серии операций, что позволяет
   * усреднить результаты и построить стабильную статистику. Внутренний цикл
   * последовательно (или случайно) выбирает блоки и выполняет реальные вызовы
   * pread/pwrite. Каждое повторение замеряется при помощи CLOCK_MONOTONIC, чтобы
   * получить точное время выполнения без влияния изменений системного времени.
   */
  int repetition_index = 0;  // счётчик текущего повторения цикла, используемый для сообщений и контроля количества итераций
  size_t block_index_iter = 0;  // счётчик обработки блоков внутри повторения, позволяющий итерироваться по block_count_total
  for (repetition_index = 0; repetition_index < repetitions_total; ++repetition_index) {  // выполняем заданное пользователем число повторов, пока не достигнем repetitions_total
    struct timespec _start_iter, _end_iter, _diff_iter;  // структуры для замера времени повторения, включающие секунды и наносекунды
    clock_gettime(CLOCK_MONOTONIC, &_start_iter);  // фиксируем начало повторения, используя монотонные часы для стабильности измерений
  printf("IO: Iteration %d: ", repetition_index + 1);  // выводим прогресс текущего прогона в stdout, чтобы итоговый лог эксперимента сразу содержал порядковый номер
    for (block_index_iter = 0; block_index_iter < block_count_total; ++block_index_iter) {  // перебираем блоки внутри повторения, выполняя операции block_count_total раз
      off_t current_block_index = is_sequence_access ? (off_t)block_index_iter % blocks_in_region : rand() % blocks_in_region;  // выбираем индекс блока в зависимости от режима доступа, обеспечивая либо последовательность, либо равномерный случай

      off_t current_offset_bytes = io_range_start + current_block_index * (off_t)block_size_bytes;  // вычисляем смещение в файле для выбранного блока, комбинируя базу диапазона и индекс блока

      // -------------------- Операция IO --------------------  // выполняем либо запись, либо чтение блока по вычисленному смещению
      if (do_write_flag) {  // ветка для режима записи, где данные из буфера отправляются в файл
        ssize_t written_bytes = pwrite(fd_file, buffer_ptr, block_size_bytes, current_offset_bytes);  // записываем блок данных в файл по указанному смещению, используя позиционный ввод-вывод
        if (written_bytes != (ssize_t)block_size_bytes) {  // проверяем, что записан полный блок, иначе ищем причину
          if (written_bytes < 0) {  // если запись завершилась ошибкой, значит pwrite вернул отрицательное значение
            perror("pwrite");  // выводим причину ошибки записи, извлекая текст из errno
          } else {  // иначе запись была укороченной, что может означать заполнение диска или сигналы
            fprintf(stderr, "Short write %zd\n", written_bytes);  // предупреждаем о неполной записи блока, фиксируя фактический объём
          }  // конец ветки укороченной записи, информирующей о частичном результате
        }  // закрываем проверку количества записанных байтов, подтверждая успех операции
      } else {  // режим чтения из файла, при котором данные поступают в буфер
        ssize_t read_bytes = pread(fd_file, buffer_ptr, block_size_bytes, current_offset_bytes);  // считываем блок данных из файла по смещению, не меняя глобальный указатель позиционирования
        if (read_bytes != (ssize_t)block_size_bytes) {  // проверяем, что считан полный блок, чтобы исключить неожиданные ранние EOF
          if (read_bytes < 0) {  // обрабатываем ошибку чтения, если pread вернул отрицательную величину
            perror("pread");  // выводим описание ошибки чтения, используя errno для большей информативности
          } else {  // иначе блок считан не полностью, что может указывать на конец файла или усечённый диапазон
            fprintf(stderr, "Short read %zd\n", read_bytes);  // сообщаем о неполном чтении блока, фиксируя фактический размер результата
          }  // завершение ветки укороченного чтения, предоставляющей контекст пользователю
        }  // конец проверки количества прочитанных байтов, гарантируя, что буфер заполнен полностью
      }  // окончание ветки чтения/записи, после которой можно перейти к следующему блоку
    }  // завершение цикла по блокам, покрывающего все запланированные операции внутри текущего повторения
    clock_gettime(CLOCK_MONOTONIC, &_end_iter);  // фиксируем время окончания повторения, чтобы вычислить длительность итерации

    _diff_iter.tv_sec = _end_iter.tv_sec - _start_iter.tv_sec;  // вычисляем разницу секунд между началом и концом, получая грубую составляющую времени
    _diff_iter.tv_nsec = _end_iter.tv_nsec - _start_iter.tv_nsec;  // считаем разницу наносекунд, добавляющую точность измерений
    if (_diff_iter.tv_nsec < 0) {  // нормализуем результат, если разница наносекунд отрицательная из-за заимствования секунды
      _diff_iter.tv_sec -= 1;  // заимствуем одну секунду, уменьшая целую часть
      _diff_iter.tv_nsec += NSEC_PER_SEC;  // добавляем эквивалент наносекунд, чтобы итог оставался корректным и положительным
    }  // завершение нормализации временного интервала, приводя результат к каноническому виду
    double elapsed_iter = _diff_iter.tv_sec + _diff_iter.tv_nsec / (double)NSEC_PER_SEC;  // переводим разницу времени в секунды с дробной частью, подготавливая её к выводу
  fprintf(stderr, "elapsed: %.6f s\n", elapsed_iter);  // публикуем длительность повторения в stderr, изолируя диагностические тайминги от основных данных stdout
  }  // конец основного цикла повторений, после которого выполнены все запрошенные серии операций

  // -------------------- Завершение --------------------  // освобождаем ресурсы и выводим финальное сообщение
  /*
   * После завершения всех операций важно аккуратно освободить выделенную
   * память и закрыть файловый дескриптор, чтобы не оставлять утечки ресурсов.
   * Финальное сообщение суммирует основные параметры запуска, подтверждая
   * успешное завершение сценария.
   */
  free(buffer_ptr);  // освобождаем выделенный буфер памяти, возвращая систему в исходное состояние и предотвращая утечку
  close(fd_file);  // закрываем файловый дескриптор, уведомляя ядро о конце работы с файлом

  printf(  // сообщаем итоговую сводку параметров работы утилиты, подтверждая, что сценарий завершён
      "IO loader completed (rw=%s, block_size=%zu, block_count=%zu, "  // форматируем сообщение с параметрами, фиксируя режим операции и размер блока
      "repetitions=%d)\n",  // добавляем количество повторений в вывод, завершая строку переводом строки
      rw_mode_str,  // подставляем режим работы read/write, чтобы легче соотнести результаты замеров с конфигурацией
      block_size_bytes,  // выводим размер блока, подтверждая величину атомарной операции
      block_count_total,  // сообщаем количество блоков, отражая масштаб выбранного теста
      repetitions_total  // указываем число повторений, что помогает интерпретировать суммарное время
  );  // завершаем печать сводного сообщения, отправляя его в стандартный вывод

  return 0;  // завершение программы с кодом успеха, сигнализирующим о корректном выполнении сценария IO
}  // конец функции main, возвращающей управление операционной системе