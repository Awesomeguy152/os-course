#include "../lib/cpu-sort.h"  // подключаем заголовок с объявлениями сортировок, чтобы обеспечить согласованность прототипов между библиотекой и исполняемым модулем
#include <stdio.h>  // используем стандартный ввод-вывод для печати результатов сортировок
#include <time.h>  // необходим для структуры timespec и функции clock_gettime, позволяющих измерять длительность выполнения

#define NSEC_PER_SEC 1000000000L  // число наносекунд в секунде; применяется при нормализации времени выполнения

// ---------------------------------------------------------------------------
// Реализация быстрой сортировки (Quick Sort)
// ---------------------------------------------------------------------------
/*
 * Быстрая сортировка (O(N log N) в среднем) использует стратегию "разделяй и
 * властвуй": выбранный опорный элемент (pivot) делит массив на две части, после
 * чего каждая часть сортируется рекурсивно. Эта функция модифицирует массив на
 * месте, не требуя дополнительной памяти помимо стека вызовов.
 */
void quick_sort(int *arr, int left, int right) {  // принимает массив целых чисел и границы подмассива, который нужно отсортировать
    if (left >= right) return;  // базовый случай рекурсии: если подмассив пустой или из одного элемента, сортировка не требуется
    int pivot = arr[(left + right) / 2];  // выбираем опорный элемент как средний по индексу; простой и достаточно эффективный выбор для демонстрации
    int i = left, j = right;  // инициализируем указатели, которые будут двигаться навстречу друг другу, переставляя элементы относительно pivot
    while (i <= j) {  // основной цикл partition: выполняется, пока указатели не пересеклись
        while (arr[i] < pivot) i++;  // сдвигаем левый указатель вправо, пока не найдём элемент, который должен быть справа от pivot
        while (arr[j] > pivot) j--;  // сдвигаем правый указатель влево, пока не найдём элемент, который должен быть слева от pivot
        if (i <= j) {  // когда i и j указывают на несоответствующие элементы, меняем их местами
            int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;  // обмен значениями, перемещающий элементы в правильную половину
            i++; j--;  // продвигаем оба указателя, чтобы продолжить поиск несортированных элементов
        }
    }
    quick_sort(arr, left, j);  // рекурсивно сортируем левую часть, ограниченную исходным left и новой правой границей j
    quick_sort(arr, i, right);  // рекурсивно сортируем правую часть, начиная с обновлённого i и заканчивая исходным right
}

// ---------------------------------------------------------------------------
// Реализация пузырьковой сортировки (Bubble Sort)
// ---------------------------------------------------------------------------
/*
 * Пузырьковая сортировка (O(N^2)) совершает множественные проходы по массиву.
 * На каждом проходе сравниваются соседние элементы, и при нарушении порядка
 * они меняются местами. Это наглядный, но не самый эффективный алгоритм,
 * который хорошо подходит для сравнения с более быстрыми методами.
 */
void bubble_sort(int *arr, int n) {  // принимает массив и количество элементов, которые нужно отсортировать
    for (int i = 0; i < n - 1; ++i) {  // внешний цикл выполняет n-1 проход, каждый раз "пузыря" крупные элементы в конец массива
        for (int j = 0; j < n - i - 1; ++j) {  // внутренний цикл сравнивает соседние пары в несортированной части массива
            if (arr[j] > arr[j + 1]) {  // если элементы стоят в неправильном порядке, то меняем их местами
                int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp;  // обмен местами, который поднимает больший элемент ближе к окончанию массива
            }
        }
    }
}


// ---------------------------------------------------------------------------
// Точка входа: замер времени сортировок и вывод результатов
// ---------------------------------------------------------------------------
int main() {  // демонстрационная точка входа, показывающая работу обоих алгоритмов и измеряющая суммарное время
    struct timespec _start, _end, _diff;  // создаём структуры для хранения отметок времени начала, конца и разницы выполнения
    clock_gettime(CLOCK_MONOTONIC, &_start);  // фиксируем момент старта с использованием монотонных часов, чтобы избежать влияния изменения системного времени
    int arr1[] = {5, 2, 9, 1, 5, 6};  // исходные данные для быстрой сортировки; массив выбран для демонстрации перестановок и повтора значений
    int n = sizeof(arr1)/sizeof(arr1[0]);  // рассчитываем число элементов массива, используя отношение общего размера к размеру одного элемента
    quick_sort(arr1, 0, n-1);  // запускаем быструю сортировку на всём диапазоне массива arr1
    printf("Quick sort: ");  // выводим заголовок, чтобы отделить результат сортировки от других сообщений
    for (int i = 0; i < n; ++i) printf("%d ", arr1[i]);  // печатаем каждый элемент отсортированного массива, демонстрируя возрастание
    printf("\n");  // добавляем перевод строки, чтобы следующий вывод начинался с новой строки

    int arr2[] = {3, 7, 4, 9, 5, 2};  // набор данных для пузырьковой сортировки, отличный от arr1 ради демонстрации алгоритма
    bubble_sort(arr2, n);  // сортируем массив arr2 пузырьковым алгоритмом, используя то же количество элементов n
    printf("Bubble sort: ");  // выводим заголовок для результатов пузырьковой сортировки
    for (int i = 0; i < n; ++i) printf("%d ", arr2[i]);  // выводим отсортированные элементы, показывая результат более простого алгоритма
    printf("\n");  // завершаем строку вывода, чтобы визуально отделить данные от отчёта по времени
    clock_gettime(CLOCK_MONOTONIC, &_end);  // фиксируем время завершения всех операций, используя те же часы для корректного сравнения
    _diff.tv_sec = _end.tv_sec - _start.tv_sec;  // вычисляем разницу секционной части времени между стартом и окончанием
    _diff.tv_nsec = _end.tv_nsec - _start.tv_nsec;  // вычисляем разницу наносекундной части, чтобы получить точное значение длительности
    if (_diff.tv_nsec < 0) {  // проверяем, не ушла ли наносекундная часть в отрицательное значение после вычитания
        _diff.tv_sec -= 1;  // компенсируем отрицательный результат, занимая одну секунду из целой части
        _diff.tv_nsec += NSEC_PER_SEC;  // добавляем эквивалент секунды в наносекундах, нормализуя структуру времени
    }
    double elapsed = _diff.tv_sec + _diff.tv_nsec / (double)NSEC_PER_SEC;  // преобразуем разницу в секунды с дробной частью для удобного вывода
    fprintf(stderr, "elapsed: %.6f s\n", elapsed);  // отправляем длительность работы в поток ошибок, чтобы отделить её от основного вывода
    return 0;  // завершаем программу кодом успеха, показывая, что демонстрация прошла без ошибок
}
